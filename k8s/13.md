# Outputs

```
purfreak@Tashas-MBP:/git/core-course-labs$ kubectl get po,sts,svc,pvc
NAME               READY   STATUS    RESTARTS   AGE
pod/app-python-0   1/1     Running   0          15s
pod/app-python-1   1/1     Running   0          15s
NAME                          READY   AGE
statefulset.apps/app-python   2/2     15s
NAME                 TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
service/app-python   NodePort    10.210.12.134   <none>        8000:31912/TCP   15s
NAME                                            STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE
persistentvolumeclaim/counter-py-app-python-0   Bound    pvc-n1zenjj1-p12j-as0d-1mks-81z2uznasy3n   10Mi       RWO            standard       15s
persistentvolumeclaim/counter-py-app-python-1   Bound    pvc-7dnaj2bd-29na-m29s-pqw9-75masn48nam1   10Mi       RWO            standard       15s
```

```
purfreak@Tashas-MBP:/git/core-course-labs$ kubectl exec app-python-0 -- cat /data/visits.txt
0
```

```
purfreak@Tashas-MBP:/git/core-course-labs$ kubectl exec app-python-1 -- cat /data/visits.txt
15
```

# Ordering Guarantee and Parallel Operations

## Explain why ordering guarantees are unnecessary for your app.

No need to maintain ordering in pods launch if there are no state which need to be transfered to all pods (which is my case).

## Implement a way to instruct the StatefulSet controller to launch or terminate all Pods in parallel.

Just add `podManagementPolicy` in statefulset.yaml

# Update Strategies

- **Rolling Strategy Deployment:**

  - This strategy ensures seamless updates by waiting for new pods to become ready before scaling down the old ones, allowing for potential issue aborts in Kubernetes deployments.

- **Recreate:**

  - While straightforward, the recreate deployment strategy introduces a brief downtime as it replaces all old pods with new ones simultaneously.

- **Blue/Green Deployments:**

  - Blue/Green deployments provide a risk-mitigated approach, allowing users to interact with the old version until the new version is tested and approved before redirecting traffic.

- **Canary Deployments:**

  - This method offers a cautious and progressive release of new functionality, initially deploying to a limited audience before expanding to the entire infrastructure.

- **Canary Deployments with Flagger:**

  - Flagger automates the canary deployment process, dynamically adjusting traffic based on performance metrics and providing communication of results, often through platforms like Slack.

- **Dark Deployments (A/B Testing):**

  - A/B testing, or dark deployments, enables monitoring user interactions and metrics impact by quietly introducing a new feature to a select group of users.

- **Flagger and A/B Deployments:**
  - In addition to canary deployments, Flagger extends its functionality to facilitate A/B testing scenarios, making it versatile for controlled feature rollouts and assessments.
